#pragma once
#include <cstddef>
#include <Windows.h>
#include "runtime.h"

namespace ext
{
    std::size_t get_string_length(const WCHAR *pointer)
    {
        std::size_t result = 0;
        while (pointer[result] != L'\0')
        {
            ++result;
        }
        return result;
    }

    class string_t
    {
        WCHAR *buffer;
        std::size_t length;
        std::size_t capacity;

    public:
        string_t() : buffer(nullptr), length(0), capacity(0) {}
        string_t(const string_t &&lv) : buffer(nullptr), length(lv.length), capacity(lv.capacity)
        {
            buffer = alloc<WCHAR>(length);
            for (std::size_t i = 0; i != length; ++i)
            {
                buffer[i] = lv.buffer[i];
            }
        }
        string_t(string_t &&r) : buffer(r.buffer), length(r.length), capacity(r.capacity)
        {
            r.buffer = nullptr;
            r.length = 0;
            r.capacity = 0;
        }
        string_t(const WCHAR *pointer) : string_t()
        {
            length = get_string_length(pointer);
            capacity = length + 1;
            buffer = alloc<WCHAR>(capacity);
            for (std::size_t i = 0; i != capacity; ++i)
            {
                buffer[i] = pointer[i];
            }
        }
        ~string_t()
        {
            if (buffer != nullptr)
            {
                free(buffer);
            }
        }

        const string_t &operator=(const WCHAR *pointer)
        {
            length = get_string_length(pointer);
            capacity = length + 1;
            buffer = alloc<WCHAR>(capacity);
            for (std::size_t i = 0; i != capacity; ++i)
            {
                buffer[i] = pointer[i];
            }
        }

        operator WCHAR *() const
        {
            return buffer;
        }
        std::size_t get_length() const
        {
            return length;
        }
        std::size_t get_size() const
        {
            return sizeof(WCHAR) * length;
        }
    };
}
