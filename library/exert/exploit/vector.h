#pragma once

#include <cstddef>

namespace ext
{
    template <typename T>
    class vector_t
    {
        T *buffer;
        std::size_t length;
        std::size_t capacity;

    public:
        vector_t() : buffer(nullptr), length(0), capacity(0) {}
        ~vector_t()
        {
            if (buffer != nullptr)
            {
                free(buffer);
            }
        }
        void push(const T &one)
        {
            if (length >= capacity)
            {
                resize((capacity > 0 ? capacity : 1) << 1);
            }
            std::size_t index = length > 0 ? length - 1 : 0;
            new (buffer[index]) T(one);
        }
        T *begin() const
        {
            return buffer;
        }
        T *end() const
        {
            return buffer + length;
        }

    private:
        void resize(std::size_t new_size)
        {
            T *new_buffer = alloc<T>(new_size);
            for (std::size_t i; i != length; ++i)
            {
                new_buffer[i] = buffer[i];
            }
            free(buffer);
            buffer = new_buffer;
        }
    };
}