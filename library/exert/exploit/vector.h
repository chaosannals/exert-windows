#pragma once

#include <new>
#include <cstddef>
#include "runtime.h"

namespace ext
{
    template <typename T>
    class vector_t
    {
        T *buffer;
        std::size_t length;
        std::size_t capacity;

    public:
        vector_t() : buffer(nullptr), length(0), capacity(0) {}
        vector_t(const vector_t &lv) : buffer(nullptr), length(lv.length), capacity(lv.length)
        {
            resize(lv.capacity);
            for (std::size_t i = 0; i != length; ++i)
            {
                buffer[i] = lv.buffer[i];
            }
        }
        vector_t(vector_t &&r) : buffer(r.buffer), length(r.length), capacity(r.capacity)
        {
            r.buffer = nullptr;
            r.length = 0;
            r.capacity = 0;
        }
        ~vector_t()
        {
            if (buffer != nullptr)
            {
                for (std::size_t i = 0; i != length; ++i)
                {
                    // buffer[i].~T();
                }
                recov(buffer);
            }
        }
        void push(const T &one)
        {
            if (length >= capacity)
            {
                resize((capacity > 0 ? capacity : 1) << 1);
            }
            std::size_t index = length++;
            new (buffer + index) T(one);
        }
        T *begin() const
        {
            return buffer;
        }
        T *end() const
        {
            return buffer + length;
        }
        std::size_t get_length() const
        {
            return length;
        }

    private:
        void resize(std::size_t new_size)
        {
            T *new_buffer = alloc<T>(new_size);
            for (std::size_t i; i != length; ++i)
            {
                new_buffer[i] = buffer[i];
                // buffer[i].~T();
            }
            recov(buffer);
            buffer = new_buffer;
            capacity = new_size;
            file_putln(L"resize.log", L"new buffer");
        }
    };
}